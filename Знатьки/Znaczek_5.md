### Znaczek #5:

_Тута я скопипастил все свои обсуждения ещё онлайновой версии пада для TDT._
_Опять же, всё без разделителей между разными комментариями._

---

Уф.

Я-то думал, сейчас для пада все хоть сколько-нибудь полезные плагины установлю, базу данных с репликацией зафигачу, и уже можно юзать!  
Оказалось, что плагины тупо конфликтуют друг с другом, и после установки второго десятка, ядро самого пада упало и больше не запускалось.

Пришлось откатывать. И откатывать…  
Даже в полудохлом состоянии (в среднем 3/5 попыток входа обламываются, пад вылетает или рушится сервер) эта куча кнопок и панелей перекрывали друг друга, прыгали, ломались…

Я думал, выберу ВСЕ (кроме очевидно не нужных нам) плагины, а потом удалю те, что, оказывается, тоже не полезны.  
Нифига! Надо переустановить всё с нуля, и ставить их поштучно. Проверяя ПОЛНУЮ работоспособность всех функций пада, и ещё отмечать отдельно для себя, какие плагины и в какой последовательности я ставил.

Не, это всё потому, что их там КУЧА. Плюс, функционал некоторых дублируется, и было слишком наивно полагать, что такое не сконфликтует друг с другом…

Ладно. Зато из хорошего, что я нашёл:  
– поддержка тегов sub/sup, которые можно переопределить для сокрытия текста, вместо зачёркивания.  
– якорные ссылки типа [[так]], как у Свимика.  
– потенциальная возможность загружать файлы (проверить не мог, то ли не встала, то ли сломалась)  
– отображение авторов в паде (видимо тоже маркерами)  
– возможность поиска по истории на временной шкале, где будут подсвечены места, где есть заданное слово. Также, виден момент, когда его уже удалили.  

И что неплохо бы найти:  
– разделение пада на «шапку» и «тело» с независимой нумерацией, тоже как у Свимика.  
– возможность смотреть лог сервера типа как чат, в котором бы показывались события редактирования. Он бы позволил узнать, кто произвёл удаление чего-то.

Короче.  
Я тут несколько часов тыкал в плагины для пада, проверяя каждый отдельно, и изучая их возможности.  
Вот отчёт: <http://klimaleksus.narod.ru/Files/D/epl.zip>

Ещё из хорошего:  
– Есть плагин с отличной палитрой! Осталось её настроить.  
– Можно менять цвета текста, как один из видов форматирования (то есть аналогия – «жирный» и «красный»), допись внутрь не теряет цвет. Список цветов настрою.  
– Метки пользователей, они показывают точное положение курсора ввода, но кратковременно. Надо изменить, чтобы на строке тоже оставалась постоянная метка. Ещё есть «слежение» за участником.  
– Два плагина, показывающих авторство при наведении на текст. Один делает это красиво и с задержкой, но не понимает цвета уже вышедших. Другой – показывает всех стандартными всплывающими подсказками, но не обновляется при изменении имён и не отключается кнопкой…  
– Есть возможность вставлять картинки прямо в пад! Вот прям скопировать картинку – и вставить её. Или можно ввести ссылку, картинка скачается, и её можно будет «оторвать» от ссылки.  
– Заголовки и горизонтальные линии, но там ещё пообрезать кое-то надо.  
– Меняющийся размер чата, прям как на Пиратенпаде. Но можно ли раздвигать список пользователей, я пока не понял.  
– Подсветка синтаксиса, которую можно настроить так, чтобы она, к примеру, всякие «Twilight:» – заголовки реплик серыми делала, например. Я всё хотел прикрутить такое, чтобы текст от начала английской реплики до первой русской буквы был бы на слегка сером фоне, но мне не удалось пока; либо это ценой предыдущего, там регулярки конфликтуют. Или два «языка» делать.  
– Оу, пад стал русским! А я лишь «en-gb» на «ru-ru» поменял…

Из неприятного:  
– Ссылки на [[текст]] не работают, или требуют ещё какого-то плагина.  
– Как сделать кликабельные номера строчек, чтобы переходить по ним – не понял, хотя аж два плагина предлагали возможность перехода к строкам по якорю в ссылке.  
– Как запаролить пад, я пока не разобрался. В наскок прошлый раз же всё поломалось, а там есть порядка 3-5 плагинов, предлагающих эту возможность.  
– Пад часто «не прогружается» с какой-то страшной ошибкой (поменять бы её текст…), но есть решение: зажать «Ctrl+R» или «F5», чтобы обно-обно-обно-обновить страницу.  
– Картинки на кнопках иногда не отображаются в Firefox.  
– Возможность получать информацию о том, кто удалил кусок текста, не предоставляется никаким плагином, вроде бы. И пока не понятно, как сделать её (знали бы вы, что там за 1+\*b+0-f/5\* в базе храниться…), но как-то же можно.  
– Закладок на строки нет. А штука ведь была полезная, надо из моего браузерного плагина вытащить.  

Я понял, что проще вытаскивать логику плагинов, перерабатывать её, и вставлять в СВОЙ. Причём, в единственный. Ну или хотя бы группировать по общим свойствам, чтобы не было, что, грубо говоря, для жирного текста один плагин, а для курсива – другой.  
Более того, они ещё и неписаны неоптимально. От большого количества всё лагает.  
И сам интерфейс ядра пада какой-то хромой.  

Короче, что я подумал: зачем наворачивать его до полного блеска, то самой последней фишечки?  

Ведь быть может, мы завтра попробуем его, и окажется, что он либо рушится, либо никого не устраивает, либо в нём невозможно работать…

Я пока базовый функционал отладил (может сейчас ещё кликабельными номера строчек сделаю…), давайте хотя бы так его проверим.

Без внешней базы данных, без репликации на другой хост (всё это нужно серьёзно отлаживать) – всё будет хостить кто-то на своей машине. Все пады сохраняются в один файлик «черновой базы», и тут даже паролить не нужно – можно выбрать весьма рандомный порт, и никто просто не будет знать, как достучаться до пада.

На всякий случай, можно сделать один и заблокировать создание других падов.

…что за отстой, почему в новом паде нельзя отменять выбеливание!?  
«Error: Can't apply USER_CHANGES, because  
Trying to submit changes as another author in changeset …».

Более того, случайное нажатие ЛЮБЫМ участником комбинации Ctrl+Shift+C – очищает все авторские цвета документа сходу, а следующее же за ним Ctrl+Z – не срабатывает и выбрасывает из пада, потому что сервер думает, что клиент пытается что-то чужими цветами писать.

Я манал.  
Всё, я пошёл системные файлы ядра корректировать…

Странно, на этой строке стоит комментарий:  
// the empty author is used in the clearAuthorship functionality so this should be the only exception  
if('author' == …

– значит что-то другое вызывает глюк. Пофиг, закомменчу проверку.

Оу май пад!  
<http://klimaleksus.narod.ru/Files/D/TDTPad.rar> (~28 Мб)

Сделано в моих плагинах:  
• форматирование текста + смена шрифта, его размера и цвета – сохраняется как атрибут (т.е. применяется к части текста), глобально.  
• Масштаб текста всего пада, локальный для каждого.  
• Горячие клавиши: Ctrl+S – зачеркнуть, Ctrl+D – выбелить, Ctrl+E – скрыть (ниже); блокировка Ctrl+Q и Ctrl+W, а также подтверждение на F5.  
• «@», показывающая что изменения сохранились. Должны быть зелёная/синяя, но будет, видимо, голубая/красная.  
• Сокрытие текста по кнопочке «H» на панели, или Ctrl+E. Работает так: если выделен текст, то он будет свёрнут в одну пунктирную «|», это глобально для всех. Если текст не выделен, то команда развернёт (или свернёт обратно) ЛОКАЛЬНО весь скрытый текст в строке с курсором, он будет взят в пунктирную рамочку. Для глобального снятие скрытия, можно выделить «|» с мясом, и нажать Ctrl+E несколько раз: сначала все свернётся в одну, затем локально раскроется но останется выделенным, и наконец – рамочка и атрибут скрытия будут сняты (это проще, чем я описал).  

• Разбиение пада на секции, ОЧЕНЬ полезная функция. Секцию начинает строка «==Х», где вместо Х – одна русская заглавная буква, или пробел. Например:  
==Ш==  
== == // Основной раздел  
==П== // песня  
– тогда все строки, начиная с этой, будут перенумерованы в  
Ш1  
Ш2  
…  
1  
2  
…  
П1  
П2  
…  

– пробел вместо буквы обозначает «обычную» нумерацию без префикса. Естественно, добавление новых строчек в разные секции не собьёт их новую нумерацию (номера обновятся через секунду после изменения). Технически, названия секций могу совпасть, но это нежелательно. Отсюда вытекает:  
• Быстрый прыжок на строку. Работает и в чате, и в паде – просто двойной щелчок по «номеру» строки в тексте (число N, либо буква+число XN). Номера никак не выделяются ни в паде, ни в чате, но двойной клик по ним сработает. Разумеется, с учётом секций (обязательно ставьте именно русскую букву перед номером). Технически, прыжок на самую первую строку невозможен.

Включённые плагины, но я внёс в них изменения:

• Палитра. Я вручную выбрал оттенки и их параметры яркости. Хотя, исходный колор-пикер на любой цвет я убирать не стал, так что всегда можно взять свой цвет.  
• Вставка картинок в пад. Я наспех добавил туда ещё одну опцию размера (там было 100%, 50%, 25% от ширины пада) – исходный размер картинки. Кстати, изменения этих размеров (нажатия на квадратики внизу) – глобальны для всех!  
• Изменяемый размер чата. Он глючный, короче: чтобы раздвинуть его, возьмите мышью за полоску, потом поднимите курсор наверх на панель (а не на пад), и тащите там. По паду на тащится. И совсем свернуть его тоже нельзя.

Плагины как есть:  
• звёздочка в заголовке, когда пад был отредактирован кем-то во время того, как окно браузера не было на переднем плане. Потом туда надо и кол-во непрочитанных в чате выводитью.  
• Проверка орфографии. Кстати, отключается в настройках на панели.  
• Локальная отмена переноса текста по словам. Не отлаживал, меняется тоже в панели настроек.

Глюки пада:  
• Грёбанная панель сверху!! У меня иконки на ней постоянно пропадают! Помогает Ctrl+колёсико (масштаб), сворачивание и разворачивание окна, открытие других вкладок. В общем, бред какой-то, я манал. Потом придумаю, как переделать…  
• Кнопка «сохранить ревизию», я хотел её в панель настроек убрать, но уф, короче, просто забейте на неё, она бесполезна.  
• Таймслайдер имеет какой-то отвратительный интерфейс, но функционал норм.  
• Кстати, плагин «поиска текста в истории» при работе нагружает ЦП сервера на 100%, так что я его вырубил пока.  
• Если увидите страшную чёрно-красную ошибку – удержите Ctrl+F5, чтобы хорошенько обновить вкладку.

Планы:  
• Закладки на строки, как в моём том плагине. С учётом секций.  
• Метки, кто где находится, и возможность узнать автора любого текста. На самом деле я оставил выключенными несколько плагинов, их потом можно будет опробовать. Но они могут затормозить пад.  
• Сервер-лог, о том, кто где сколько, когда и чего сделал (добавил или удалил, и примерно на какой строке). Я уже придумал, как, но опять-таки требует аккуратной отладки, пока рисковать не стал.  
• Может быть: автоматическое выделение другим цветом английского текста в строчках, глобальные динамические закладки, или ещё что-нибудь прикольное.

Установка:  
1\) Распаковать архив в корень диска. Имя папки должно быть коротким, например C:\ep\ или D:\tdtpad\  
2\) Открыть и отредактировать «settings.json». Там сверху вписать свой ПУБЛИЧНЫ адрес IP, на который нужно будет всем заходить. Номер порта тоже можно поменять.  
3\) Запустить «START.BAT». Это откроет большое окно лога сервера. (А программа «nircmd.exe» нужна для повышения его приоритета, и чтобы если вдруг сервер упадёт – был звуковой сигнал и уведомление).  
4\) Зайти на http://IP:PORT/ и создать новый пад. (делайте сразу два: один основной, а второй для тестирования).  
5\) Чтобы запретить создание новых падов, закройте сервер (это огромное консоль – сам сервер и есть, его закрытие останавливает пад), и раскомментируйте «"editOnly" : true,» в «settings.json». Перезапустите «START.BAT».  
6\) Пока плевать на «пользователей» (я отключил администрирование), и на «текст по умолчанию» – легче просто в паде сразу текст изменить.  

Я ещё и кроссбраузерность потом настраивал!  
И парсер чата, чтобы найденные номера строк ссылки не пороли…

Но мне кажется, он должен запуститься без проблем с первой же попытки.

Вот скрипт, чтобы подгрузить все сообщения в чате любого пада (например, если нужно что-то найти по тексту в истории чата):

//////  
(function(B,L,F,I){  
B=document.getElementById('chatloadmessagesbutton');  
if(!B)B=document.getElementById('chatloadmore');  
if(!B){return alert('Не найдена кнопка!');}  
I=setInterval(function(){  
if(B.style.display=='none')return;  
B.click();},50);  
F=function(E){if(!E.altKey)return;  
document.removeEventListener('click',F,true);  
clearInterval(I);alert('Остановлено.')};  
L=document.addEventListener('click',F,true);  
})();  
//////

– он просто жмёт по кнопке автоматически, как очередная пачка сообщений прогрузилась.  
Для отмены-остановки – щёлкните в чат с зажатым Alt. (Ещё нужно это сделать после того, как все загрузятся.)  
Остановить можно в любой момент, а чтобы продолжить – просто выполните скрипт ещё раз.

Запуск, естественно – вставить в консоль браузера (Ctrl+Shift+K/J)

Блин, это правда, что если в паде выделить весь текст и удалить его, а потом отменить удаление – то весь текст для всех остальных будет иметь цвет того, кто удалял его?  
То есть он сам увидит, будто все цвета остались какими были, но все остальные – увидят лишь его цвет?  
(то есть нельзя отменить удаление всего текста так, чтобы не присвоить его потом себе)

А то я тут пытаюсь придумать, как сделать так, чтобы по Ctrl+С, Ctrl+V из одного пада в другой все цвета авторов сохранились.  
Сама авторская система, видимо, дико повязана на том, что нельзя писать чужим цветом. На каком-то этапе предлагаемый цвет меняется на фактический цвет автора.

\*прошло 40 минут безуспешный попыток найти нужный кусок кода\*

СУКА! Вот оно: («changesettracker.js»)

// Sanitize authorship  
// We need to replace all author attribs with thisSession.author, in case they copy/pasted or otherwise inserted other peoples changes  
…  
(далее нехилая функция размером в два экрана)

Закомментировал.

Теперь вставлять текст можно прямо с чужими цветами, и норм.

Правда, простое копирование тоже сохраняет цвет скопированного.  
Видимо, нужна будет кнопка не только «выбелить», но и «присвоить себе», чтобы окрасить кусок текста своим цветом.

А ещё во всем этом мало толку, если нельзя «входить под другим автором», то есть выбирать свой идентификатор (типа «a.Xv8BLjRJhw0fr9qF»), что всё равно не позволит задавать цвет тем, кого в паде не было.

Видимо, на этот счёт нужно ещё что-то придумывать: адекватный способ, как во-первых, импортировать HTML вместе со всеми авторами и их цветами (причём чтобы эти авторы-призраки формально стали действующими), а во вторых, иметь возможность менять цвета вышедшим пользователям.

Кстати, я нашёл по крайней мере одну недоработку в ядре лайта, которую даже стоит на гитхаб им запостить.  
Но я сам не хочу, там с гитом разбираться, форкать, пуллреквестить…

Клиент, отправивший чейнджсет, получает обратно лишь «true», в то время как все остальные – полную информацию и результат чейндсета.

Если я хочу сделать хук на клиенте, чтобы отслеживать все приходящий чейнджсеты – я эффективно пропускаю собственные… (нет, при отправке ловить – не вариант, там столько всего может случиться).

О-о, я знаю, что такое чейнджсет))  
А выглядит он примерно вот так:  
«Z:6v>4|7=6t\*2+4$Хех.»  
– тут кто-то написал «хех»

Оказывается, там решается такая нехилая математическая задача, о том как множество символов, называемое документом, путём некоммутативного умножения на специальную величину, называемую набором изменений, переводится в некий другой документ.  
Предлагает алгоритм как сделать так, чтобы два разных пользователя, изменившие документ одновременно, получили адекватный и ОДИНАКОВЫЙ результат в ответ на свои действия.

То есть клиенту не нужно ждать, когда сервер покажется ему, что произойдёт – потому что рассчёт гарантирует, что и у клиента, и у сервера, и у других – даст одинаоквый результат независимо от того, в какой последовательности обрабатывать данные.

(Но в самом алгоритме я конечно не разбирался. Но это блин, круто!)

Давайте гипотетически представим, что я поставил себя в рамки необходимости адаптировать под свои нужны некий open-source проект, славящийся своей «мелкая фича – стабильный релиз» системой, и кучей плагинов (которые при подходе «сначала включу все, а потом удалю ненужные» конфликтуют до умирания всего сервера, вынуждая с нуля добавлять поштучно со строгим контролем за логами), разработанными кучей людей под кучей лицензий, и всё это настолько повязано на git-подходе, что тупо багфиксить ./\*/node_modules/\*/node_modules/*/somefile.js и хардкодно прописывать туда нужные мне флаги вручную уж как-то совсем-совсем некрасиво и непортабильно получится, а на полном серьёзе делать репозитории, форки и бранчи – это прям какая-то новая ниша для меня, нырять в которую я сейчас совсем не готов.

(Нет, это уже вообще не смешно: <http://klimaleksus.narod.ru/Files/T/ep.txt> )

Плагин-то один фиг – копирнул, переименовал, МЕНЯЙ. Ну и несовместимость с исходным укажи. А если ядро?..

Итак: \src\node\handler\PadMessageHandler.js \node_modules\ep_etherpad-lite\node\handler\PadMessageHandler.js (я манал, фигли его два)

Кусок такой:

if(author == sessioninfos[sid].author) { client.json.send({"type":"COLLABROOM","data":{type:"ACCEPT_COMMIT", newRev:r}}); } else { var forWire = Changeset.prepareForWire(revChangeset, pad.pool); var wireMsg = { "type":"COLLABROOM", "data":{type:"NEW_CHANGES", newRev:r, changeset: forWire.translated, apool: forWire.pool, author: author, currentTime: currentTime, timeDelta: currentTime - sessioninfos[sid].time }}; client.json.send(wireMsg); }

– эта байда, кажется, отправляет тому клиенту, кто запостил изменения, сообщение «ACCEPT_COMMIT», а всем остальным клиентам – «NEW_CHANGES». Проблема в том, что я хочу сделать плагин, который слушает эти сообщения, и выводит (на экран или куда либо) некий лог, в котором бы в читабельном формате было понятно, какой участник внёс примерно (хотя бы, было ли это добавление или удаление) какие изменения («changeset»), и примерно где (его текущую позицию «на какой строке», кажется, отсюда не достать, но я предполагаю, что допустим, будет активен другой уже существующий плагин, постоянно постящий «CUSTOM» сообщения с координатами курсора). Я, по-видимому, упираюсь в то, что клиент не слышит своих же «NEW_CHANGES», и они не будут отображены в его локальном логе, а я по меньшей мере хочу, чтобы логи у всех были одинаковые. Можно конечно отловить момент отправки changeset’а на сервер, но это опять искать это в файлах и какие-то хаки прописывать, ещё и обработчик усложняется. К тому же, «отправил» ещё не значит, что «отправилось». Хотелось бы получить сообщение «ACCEPT_COMMIT», в котором были бы все те же данные, что и в «NEW_CHANGES». И более того, раз тут простой author==me, что делает фикс элементарным:

if(false&&author == sessioninfos[sid].author) { client.json.send({"type":"COLLABROOM","data":{type:"ACCEPT_COMMIT", newRev:r}}); } else { var forWire = Changeset.prepareForWire(revChangeset, pad.pool); var wireMsg = { "type":"COLLABROOM", "data":{type:author==sessioninfos[sid].author?"ACCEPT_COMMIT":"NEW_CHANGES", newRev:r, changeset: forWire.translated, apool: forWire.pool, author: author, currentTime: currentTime, timeDelta: currentTime - sessioninfos[sid].time }}; client.json.send(wireMsg); }

Здесь для клиента-коммитера меняется «NEW_CHANGES» на «ACCEPT_COMMIT», а все сопутствующие остаются. По идее, на работу ВСЕГО остального кода, это не должно повлиять, ведь даже если где-то слушается «ACCEPT_COMMIT», то, раз в нём ничего больше не ожидается, то важен сам факт; а лишние данные в объекте будут просто проигнорированы. Хотя и создадут некую \_мизерную\_ нагрузку на сервер/канал передачи, но учитывать такое – полный бред, особенно если задуматься о том, что похожие сообщения шлёт тот плагин, трассирующий позицию, – при КАЖДОМ щелчке мышью / движению текстового курсора от КАЖДОГО клиента, а сервер вещает это при КАЖДОМ щелчке мышью / движению текстового курсора от КАЖДОГО клиента, а сервер вещает это КАЖДОМУ клиенту (а при коммитах и того дважды), как раз включая себя!

Если поступить ещё разумнее, то с учётом имеющегося в файле var settings = require('../utils/Settings'); – моё «false» и второе ?: условие можно дополнить на нечто вроде «settings.enableSendChangesInCommit», отсутсвующее в конфиге по умолчанию, и вообще не приводящее к изменению работы приложения, без присвоения этой настройки.

Окей… <http://etherpad.org/>

«The main development happens on Github. To contribute, fork the main repo, branch off a feature branch from develop, make your changes and commit them, push to your fork and submit a pull request for ether/develop.»

– серьёзно? Делать это? А вдруг эта фича у них уже запланирована?

Или же: «If you'd like to help, get in touch!» – ссылка ведёт на mailing-list и ещё куда-то. Может об этом просто написать кому-то?

Либо же – тупо в коде поменять, и положить на всю эту опенсорсную инфраструктуру?..

1\) Я не меняю тип сообщения – следовательно всё остальное будет работать как раньше.  
2\) Да, клиенту эхнется то, что ему по сути не нужно. Но какие удобства это мне даёт при прослушке входящих сообщений!

Я вот говорю же что хочу – чтобы можно было ТОКЕН выбирать.

Чтобы я мог сделаться «a.aleksusklim___» – и тогда в какой бы пад я не вошёл – я всегда буду я, и любой, ЛЮБОЙ мой текст всегда будет моим, даже если он чёрт побери из прошлогодней истории или скопирован из другого пада.

(ну да, если кто другой впишет этот, публично видимы идентификатор – весь мой текст будет его… Но мне не жалко – в конце концов, это наш ОБЩИЙ текст, просто цвет на нём мой. Для нашего же удобства)

Так вот.  
Пад сломался от переполнения стека. Причём именно в тот момент, когда я нажал «экспорт в .ertherpad».  
Сама трёхгиговая база – абсолютно работоспособна, хотя не факт, что она верно сформирована.

Проблема в том, что в .etherpad формате должно быть сохранено всё содержимое пада, и все его ревизии. И этот формат – JSON.  
Забавно, но я уже упирался в этот баг на Апаче, причём тогда решить его не смог. Сейчас же повезло!  
Итак, рекурсивная функция заворачивания данных в JSON формат на таком огромном паде привела к переполнению стека на сервере.  
Причём Node.js сам сообщил об ошибке, потому что не упал, а достиг заданного предела.  
Однако, под Windows, этот предел нельзя просто так расширить, потому что иначе программа рухнет физически.  
Лучшее решение – действительно увеличить стек. Стандартный – всего 1Мб, а я теперь увеличил его до 16 Мб (что значит, что по крайней мере на падах, которые не более чем в 30 000 раз больше нашего – можете считать, что это тридцать тысяч часов вместо одного часа стабильной работы – на них переполнений стека возникнуть не должно).  

Для этого мне даже не пришлось перекомпилировать из исходников, я нашёл маленькую утилиту, пропачивающую программы – и применил её на «node.exe»:  
<http://klimaleksus.narod.ru/Files/D/stack.rar>

Инструкция:  
– распаковать в папку моего пада (содержимое \bin\ должно пойти в имеющийся \bin\), заменив START.BAT (там лишь один новый параметр —stack-size=15360 – виртуальный лимит на 15 Мб для Node.js)  
– зайти в \bin\ и запустить «check.bat». Выйдет много инфы (окно можно закрыть или нажат Enter), там должно быть:

100000 size of stack reserve  
1000 size of stack commit  
100000 size of heap reserve  
1000 size of heap commit

(это в шестнадцатеричной системе, если что)

– Теперь надо запустить «patch.bat». Нажать Enter, потому что окно никак не сообщит о том, что всё готово. И снова выполнить «check.bat», где на этот раз будет:

1000000 size of stack reserve  
10000 size of stack commit  
100000 size of heap reserve  
1000 size of heap commit  

Готово! Теперь можно попробовать ещё раз грузануть нашу огробазу и сделать экспорт.  
Собственно, вот он:  
<http://klimaleksus.narod.ru/Files/D/S06EP18-translate-episode-18.zip> – ага, куда экономичнее.

А теперь я вот думаю, с чего база-то так разрослась? Подозреваю что из-за плагина «вставка картинок в пад».  
Не то что бы два моих вставленных 1024\*768 скриншота очень много весили… но если в базу кладётся каждый раз полная копия текста пада в каждой ревизии, создающейся чуть ли не каждым нажатием очередной клавиши каждым участником? Хотя, я пока так и не понял, что конкретно ложится в базу. Вытащить бы как-то количественно-качественную информацию о том, чем всё-таки забит файл – текстом или же base64 картинками.

И я проведу эксперимент, специально вставляя в пад картинки и замеряя удар по объёму базы (думаю, для MySQL это в перспективе, также актуально), что поставит под вопрос необходимость в таком неэффективном плагине, хотя и удобном.

Если что, вот наша дико ужатая база, которую желательно запустить под сервером на Линуксе, и посмотреть, вылетит ли стек от попытки экспорта:  
<http://klimaleksus.narod.ru/Files/D/BD_TDTeam.rar>

Надо, чтобы эти картинки не как текст пада хранились, а просто на сервер загружались как файлы. А не в базу.  
Было бы норм.

Я там уже и с репликацией почти разобрался, но я ЧЕТЫРЕ раза свой финальный вариант запускал с нуля – и он ломался, и снова танцы с бубном.

Последний раз была проблема, что какая-то команда выполняется на Win7, и не пашет на XP, но я не понял, какая.  
А когда подгоняю под XP и дерзко тесчу на семёрке – опять баги лезут…

Так что я пока ещё потещу. Там ж ещё сам MySQL выкладывать, лучше пусть сразу всё будет норм.

Так вот. Я тут довольно долго размышлял над тем, как можно устроить в новом паде защиту от подмены персональностей участников, и пришёл к выводу, что если кто-то САМ захочет, чтобы его персональность была подменена – то с этим ничего нельзя сделать.  
Это ж как аналоговая дыра (см. википедию), а именно: если кто-то захочет, чтобы из-под его аккаунта действовал другой человек – он всегда может предоставить ему удалённый доступ к своей машине сторонними средствами, не говоря уже о возможности физически передать свой компьютер во временное пользование кому угодно.  
И тогда никто на свете не сможет доказать, кто в паде: тот, кто должен быть, или тот, кому тот захотел дать доступ.

Однако, защитить честного пользователя от попытки подмены его ник-нейма в паде злоумышленником – вполне возможно. Первоначально я рассмотрел стратегию доступа с «инвайтами». Грубо говоря, это специальные одноразовые пароли, которые генерируются для всех потенциальных пользователей пада.  
Такой инвайт хранит «второе имя» (будем так называть то, что позволит отличать одного законного пользователя от другого – то есть не видимый ник-нейм, но и не безликий ключ сессии или идентификатор автора – цвет) внутри себя. Это значит, что первый зашедший по данному инвайту – получает сессию, связанную с конкретным вторым именем.  
Два раза зайти по одному ивайту невозможно. В принципе, пользователи сами, опционально, могут генерировать новые инвайты (в том числе запасные для себя), и раздавать из другим – но тогда внутри инвайтов запоминается история, кто и кому предоставил доступ.  
От, грубо говоря, расшариваний пароля, это не спасёт, но зато администратор сможет проследить цепочку инвайтов от своего доверенного лица до ворвавшегося в пад вандала.  
Либо, если инвайты сможет создавать только администратор – то доступа в пад не будет ну у кого свыше тех, кто получил инвайт, что, с другой стороны, затрудняет сам процесс приглашения участников в пад: нельзя будет публиковать общую ссылку, по которой все смогли бы зайти. Ему придётся давать каждому свою ссылку, причём лично и секретно.  

Такой вариант в наших условиях мне показался неудобным. Зато вторая идея получше: система закрытых и открытых ключей, которые будут создаваться потенциальными участниками, и вноситься в конфигурацию пада администратором.  
Для тех кто не знает: система PGP ассиметричного RSA шифрования – это когда клиент может сгенерировать пару ключей (текстовых строк или маленьких файлов), один из которых, закрытый, он должен тайно хранить у себя; а второй, открытый – расшарить остальным, и в особенности, серверу/администратору.

Сервер может зашифровать отправляемую информацию на открытом ключе, а расшифровать её сможет только тот, у кого есть соответствующий закрытый ключ (то есть получить информацию после такого шифрования не способен даже сам сервер).  
Более того, схема позволяет клиенту зашифровать что-нибудь на своём закрытом ключе, и тогда расшифровать смогут все остальные, но именно при помощи его именного открытого ключа, что является гарантией того, что информацию послал именно он.

Итак, применительно к паду, протокол работает так. В админке пада есть страничка, куда можно добавить пары «второе имя» – «открытый ключ». При обычном входе в пад, клиентский интерфейс предлагает либо сгенерировать новый набор ключей, любо открыть/вставить имеющийся закрытый ключ.  
Участники через этот интерфейс создают пару ключей, и отправляют администратору свой логин (вернее, второе имя) и открытый ключ. Тот вносит все ключи на сервер.

Теперь, при входе в пад и выборе закрытого ключа, происходит следующее:  
– Все отправляемые сообщения (кроме приветствия, либо же в каждом будет пересылаться копия «второго имени», чтобы сервер знал, чьим ключом оперировать) от клиента серверу шифруются на его закрытом ключе. В приветствии посылается второе имя, которое сервер кладёт в сессию.  
– Сервер дешифрует входящие сообщения открытым ключом заявленного пользователя. Но если у него нет такого ключа, или он не подошёл – сообщения игнорируются и остаются без ответа.  
– Все отправляемые клиентам сообщения (именно ajax-запросы, а не сами отдаваемые .html странички или .css/.js статику – все это сервится всем желающим без разбора) шифруются на открытом ключе того, кому они предназначаются.  
– Клиенты расшифровывают приходящие сообщения на имеющемся закрытом ключе.

Всё это, без дополнительных систем токенов или проверок, гарантирует, что никто не сможет подменить собой никого другого участника без его согласия (что выразилось бы в пересылке ему своего закрытого ключа).  
Реализуется довольно просто – изменением части кода ядра пада, отвечающей за непосредственную пересылку и приём сообщений. Как я понял, там можно найти конкретные точки входа и выхода, именно на которых будет достаточно ввести шифрование.

Основная сложность тут, скорее, в самом интерфейсе удобного выбора и добавления ключей. Которые, кстати, не должны храниться в базе данных, а просто оставаться на сервере как файлы.

Я даже нашёл модуль для Node.js, со всеми необходимыми функциями – «node-rsa». Но к сожалению, я не смог заставить его работать в браузере, хотя технически это возможно (через некий «browserify», который не то уже есть в паде, не то отдельно ставится как приложение, но я манал этот линуксовый «npm install», к которому сводятся все советы по использованию…)

О, а ведь я тут действительно исследовал, мог ли плагин вставки картинок в пад быть причиной того, что наша база данных вдруг стала неоправданно большого размера.  
Итак, я создал пустой пад, и сделал PrintScreen и несколько Ctrl+V подряд. Штук шесть.  
После чего попробовал пописать. Ну вроде, ничего: база росла на глазах, но всего лишь по полмегабайта за коммит. Мало.  
Тогда я вставил туда тот же самый скриншот ещё раз десять или пятнадцать, а затем добавил снизу содержимое любого нашего типового пада. Правда у меня браузер так подвис, что сервер его выкинул. 
Ну, я перезашёл…

О-о-о, а потом моя бедная мозиллка-тормозилка в течение сорока минут пыталась прогрузить содержимое пада, медленно наращивая память (единственная вкладка) с двухсот до шестисот мегабайт. Я так и не дождался конца, сбросил Диспетчером. Не было ни уведомлений, мол, скрипт завис, ни возможности хоть на что-то нажать в интерфейсе браузера. Труп трупом.

Итого, плагин вставки картинок в пад – зло. Выглядит клёво, но взамен душу заберёт.  
Уж лучше вон тот, который локально по ссылкам на изображения эти самые изображения в паде и вырисовывает. А ещё круче, если его можно объединить с каким-нибудь механизмом, загружающим файлы на сам сервер – тогда даже ничего изобретать на надо – загрузил картинку, вставил ссылку.

Теперь насчёт того, как я разобрался с MySQL и репликацией.  
<http://klimaleksus.narod.ru/Files/4/TDTPAD_MySQL.rar> (_В архиве – ещё часть данного текста_)

Это с расчетом, что все пойдёт на ОК?  
– да не пойдёт оно, я уже пять раз так думал.  
Вот всё идеально настраивал, ставил на новый комп – и не шло.  
А там правил. Правил на мастере, правил на реплике.

Потом путался, где какие изменения.  
Или менял что-то, что по идее не должно всё испорить (вроде имени какого-нить файла), а потом на генеральной репетиции – бах, на последнем этапе ошибка именно в его названии, которое я забыл куда-то прописать.

Гуглинг ошибок. Забано, например, было видеть ответом (причём правильным), что «не найден индекс первого бинлога мастера» означает всего лишь, что репликация была подцеплена не к тому серверу (например, к своему же собственному!)

Всё же, чем больше прог что-то меняют в файлах, тем сложнее потом вмешиваться при надобности.

Например у меня сейчас root-пароль генерируется рандомом. Но он может не вступить в силу почему-то, после выполнения скрипта. А почему? А хрен знает.  
Но в процесс уже не вмешаться, там всё на автоматике.  
Пришлось часть работы оставить пользователю (например, закрыть сам MySQL, когда то будет нормально открыт, ибо скрипт у меня не то что узнать об ошибках не может, он вообще состояние сервера не в силах понять!..)

---

[Назад](./)
