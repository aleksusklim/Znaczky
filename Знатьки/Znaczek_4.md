### Znaczek #4:

_Сначала – про Нору Галь:_

---

А знаете, я наконец прочитал.

Ух.

Да уж, это было непросто!  
Интересно и познавательно. Но такую вещь на расслабоне не почитаешь, это настраиваться надо.  
А вообще – круто! Но дико. В том смысле, что может в одном или в другом, но ВСЮДУ – я бы такие выкрутасы с красивыми словечками выдавать не смог, признаю…  

Ха, возможно я тоже весьма отравлен канцеляритом. И обычно я как бы считал это преимуществом, потому что много когда владение им играет большую пользу. Другое же дело, что он и не должен ни для чего требоваться, но это уже не ко мне, я просто приспособился как мог.  
Но я ведь понимаю, когда моя речь свободная – канцеляричу как хочу – а когда я создаю некий продукт, где этому не место – и легко избавляюсь от него.  
Однако ведь автор книги призывает-то как раз из намеренного искоренения его из обыденной жизни в том числе.  

Вообще, книга переполнена её личным отношением ко ВСЕМУ. Хотелось бы больше конкретики, больше точных примеров и ничего лишнего. Нет, там очень и очень много примеров, но он часто разбавлялись возгласами «ну как так, ну сколько ж можно». Понятно конечно, что книга должна быть яркой и мотивирующей, но я-то больше предпочитаю «справочники». Хотя думаю, многим такой стиль изложения наоборот понравится.

Ой, а с этим улучшением-украшением переводимых текстов!  
Это надо постоянно как бы кричать самому себе:  
\- Бред.  
\- Но так в оригинале!  
\- Что это значит?  
\- Ну это как бы…  
\- Нет. Ещё!  
\- Это когда…  
\- Так, и?  
\- Там вот как бы…  
\- Проще!  
\- Ну там всё…  
\- Ещё проще!!  
\- Не знаю! Ну это типа…  
\- Да что это!?  
\- Это бывает, когда…  
\- Ну что это такое? ))  
\- Да это же!  
\- Ага, во-от!  
\- И ещё!..  
\- Всё, так и напиши.  

И так на каждую фразу. На примерах показывалось, как битва за каждое слово выигрывает бой за всю фразу.  
Хм… В принципе, это именно то, что делает Томас в переводе Spyro2.

Нора Галь агитирует за «дерзкий» перевод!  
О, и зря вы сказали, что последние главы можно не читать.  
Это же «Best Practices»! Ага, диву даёшься, как они выбрали именно такой вариант перевода. А ещё больше нравятся описания – которые следует бы совать в нос тому, кто в очередной раз заявит «имена не переводятся» или «так написано в оригинале».

Отсюда вытекает ещё одна проблема книги. Ну не будь она такой большой, такой тяжёлой для чтения и вникания…  
Вот кому я могу её порекомендовать? Кому захочется в ней копаться?  
Тому, кто плохо переводит? Не, если он аж настолько плохо переводит, что только полноценное прочтение такой книги ему поможет – то он и читать её не будет, у него сил и осознанности не хватит.  
Тому, кто хорошо переводит? Да, он прочтёт. Но весьма нескоро, у него и так много дел.  
Просто показать нужный отрывок в нужный момент? Но тогда не дойдёт вся мораль, весь напор повествования книги, а значит – и авторитет прочтённого.  

Вот можно сказать, что я познал истину (это как фильм «Дух времени», наверное). Не то чтобы я её не знал, но теперь я точно уверен в ней!  
Но вот «передать» эту истину через эту книгу почти невозможно.  
Нельзя заставить прочитать её.  
Тем более, нельзя заставить вникнуть в текст! (Даже я пропускал некоторые абзацы, дойдя до их середины – я и слов таких не знаю, и произведения эти не читал… Хотя теперь может «маленького принца» прочту, а то всё муми-тролль, муми-тролль…)  
Нельзя «просто сослаться» даже на отрывок, и ожидать, что перешедший по ссылке просветлеет.

Хотите обратный пример?  
Берём хренового переводчика за шкирку, и тыкаем сюда:  
<http://translations.ted.org/wiki/Рекомендации_по_оформлению_и_переводу_субтитров_на_русский_язык>  
Объявляем это истиной, и приказываем следовать. Не знаю, но по крайней мере одного переводчика, всюду писавшего в субтитрах «Вы» с большой буквы – мы таки переубедили. Но не только одной этой ссылкой… (причём жертва отбивалась неким правилом русского языка, в котором говорилось, что «на "Вы" нельзя обращаться к нескольким лицам», из чего якобы следовал вывод, что к одному лицу – можно и нужно.)

---

_Тут – как я пытался агитировать за неё среди тамошних переводчиков:_

---

Есть довольно полезная книга:  
<http://royallib.com/book/gal_nora/slovo_givoe_i_mertvoe.html>  
Интересно, знают ли о ней современные переводчики – такие как мы – ведь мне иногда кажется, что нет.  
Польза от книги огромная, но у неё есть одна проблема: это не для лёгкого чтения, и чтобы её прочитать, нужно поставить себе серьёзную цель.  

Каждый раз, встречая «имена не переводятся» или «так написано в оригинале», мне хочется бесконечно апеллировать к этой книге. Но вытаскивать оттуда цитаты не так авторитетно, как позволить самой книге открыть глаза другим.  

Одно дело, когда переводчик ошибся, что-то пропустил или неправильно понял оригинал – достаточно лишь объяснить и может даже поспорить.  
Но если же ошибочное мнение закоренело – то изменить его будет очень и очень непросто, особенно простыми разговорами.  
А тут – собрано всё самое яркое, объясняются (может даже слишком часто) последствия, вытекающие из неправильного подхода к переводу. Кажется, всем достаточно просто прочитать всё это – и качество перевода возрастёт. Либо из-за общей смены отношения, либо из-за более частого включения мозга там, где раньше использовалось «первое слово по словарю», а где-то даже из-за скромности самого переводчика, который не рискнёт предлагать плохой вариант, заведомо осознавая его низкокачественность.  

---

**SubCmpAlgo v1.1**

_– а вот что ещё я собрал._  
_Далее – большая сборная копипаста того, как я создавал алгоритм сравнения субтитров._  
_Это из разных диалогов и источников, и то лишь самое основное. Сначала я обсуждал задачу с математиками и программистами, а затем уже показывал результат переводчикам из TDT._  

---

Короче, у меня есть две числовые прямые, на них – непересекающиеся отрезки.  
Я накладываю эти прямые друг на друга, и хочу порезать на кусочки.  
Моя цель – как-то соотнести отрезки на одной прямой с отрезками на другой.  

Задание нечёткое, могу лишь примерно описать, чего хочу получить:  
Если отрезки начинаются в одинаковых местах – резать по ним.  
Если отрезки чуть-чуть сдвинуты – всё равно резать (через какую точку пройдёт – неважно, меня только интересуют группы соотнесения отрезков по участкам)  
Если отрезок не соответствует никакому на второй – пофиг, резать его одного.  
Если один отрезок поглощает другой – они должны оказаться в одной группе.  
Когда один отрезок поглощает несколько – те должны быть объединены в его группу.  
И самое главное: отрезок не должен попасть более чем в одну группу.  

Пока у меня идея – считать пустые промежутки между отрезками – тоже отрезками, тогда прямые просто разобьются точками.  
Потом найти пару противолежащих точек, между которыми наименьшее расстояние – и разбить по ним.  
Продолжать до тех пор, пока получаются разрезы.  

Верный способ? Или есть контр-пример?

Вообще, это две разные версии субтитров к одному и тому же видео, которые я хочу построчно сравнить.  
Но тайминг разный, и количество строк разное.  
Но они _примерно_ на тех же местах по времени.  

Иногда в одном файле фраза одна и длинная, а в другом – две коротких. Тогда они должны быть соединены, чтобы соответствовать.  

Так. У меня есть три файла субтитров.  
Субтитры – это наборы текстовых реплик, персонажей и тайминга.  
Тайминг – это пара начало+конец каждой реплики относительно всего файла.  
Пример:

0:17:11.42,0:17:14.59,Rarity,Who cares what some stuffy unicorn thinks of the food here.  
0:17:14.59,0:17:16.30,Rarity,It's exquisite.  
0:17:16.58,0:17:17.68,PinkiePie,That's true.  
0:17:18.24,0:17:21.64,Rarity,And you don't need three silly hooves in your window to prove it.  
0:17:21.64,0:17:23.14,PinkiePie,That's double true.  
0:17:23.44,0:17:26.48,Rarity,You just need ponies in here to give it a chance.  
0:17:26.82,0:17:29.37,Rarity,Ponies that would tell everypony else in Canterlot  
0:17:29.37,0:17:31.94,Rarity,that the "Tasty Treat" is best food in the city!  
0:17:32.16,0:17:34.24,PinkiePie,That's true times three!  

– некоторые концы совпадают с началами следующих фраз. Но это не запрещает им пересекаться.  
Вначале я хочу взять представить их как отрезки во времени, и взять объединение.  
Я соберу пересекающиеся фразы в кусочки большего размера, объединив и их текст по порядку (вчера часа в три ночи я думал, что я уже смог запрограммировать это, но теперь вижу, что нет…)  
Теперь я имею непересекающиеся (но возможно, касающиеся) отрезки, имеющие начала, концы и свой текст.

Так я поступаю с двумя файлами субтитров.  
Основная задача – вывести всё это в таблицу, как в той, что я показал. По строчкам должны располагаться подобранные реплики.  
Но основная проблема в том, что тайминг в обоих файлах на за что не совпадёт (его делали разные люди на слух). Более того, разбивка на реплики разная: где-то могут быть большие и длинные фразы, а где-то они же (это субтитры к одному и тому же видео) они разбиваются на более короткие.  

Вторая проблема в том, что сам тайминг сделан под разные релизы видео, и может быть линейное расхождение в около секунды. Ну тут какую-нибудь линейную регрессию можно устроить.  

Но основная задача – сопоставить субтитры. В итоге мне нужно, чтобы программа автоматически собирала напротив друг друга правильные фразы, которые соответствуют друг другу. Без ручного выравнивания.  

Предполагаем, что на шкале времени есть некая «информация», а две линии – это субтитры. На линиях – отрезки, которые представляют собой фразы по таймингу. Считаем, что они доносят ту же самую информацию, но не синхронны между линиями.  
Нужно порезать отрезки на группы, чтобы в каждую группу старались попасть отрезки с одинаковой информацией. Но резать можно только по границам отрезков.

Понять бы, что считать… Например, нужно ли мне максимизировать количество групп? Видимо, нет. Потому что уж если две к двум фразы никак не сходятся – то их и нужно оставить парой. Грубый пример:

1\)  
– я  
– умею разделять отрезки  

2\)  
– я умею разделять  
– отрезки  

Тут нет соответствия между фразами, их нужно оставить «две на две». Если бы в одном из них была всего одна целая фраза – она должна была бы соответствовать сразу двум.

Но чаще всего будет соответствие один к одному. Проблема в том, что программа должна предъявить лучшее разделение, основываясь исключительно на тайминге фраз, а не на их смысле в тексте, как делается вручную.

И наконец, у меня не два файла, а три. Ну, в перспективе хочется сделать общий случай для большего количества. Но три нужно точно.  
Хотя, я точно знаю, что два из них – ОДИНАКОВЫ. Но это в моём частном случае. Тут бы для двух хотя бы решить, да…

Но мне кажется, если алгоритм будет грамотный, его можно и обобщить. Однако там уже придётся потребовать хотя бы независимость от порядка, в котором на вход приходят файлы, и чтобы при одинаковости нескольких из них алгоритм дал бы тот же вердикт, как если бы файлов было меньше – без этих самых копий.

Надоело оперировать абстрактными понятиями. Собираюсь выгрузить субтитры в условную временную шкалу и по факту посмотреть, как именно по статистике на ней будут расположены настоящие точки начал и концов реплик…

Вот моё визуальное сравнение тайминга последнего эпизода:  
<http://klimaleksus.narod.ru/Files/T/asscmp0V0.htm>

Синяя шкала короче, получается временной лаг. Если настроить на три секунды (поле 300) – то примерно на середине экрана как раз выравнивается.  
Светлые полоски – «концы» отрезков (тёмные – начала), если поверх них начало следующего – то не видно.

Взаимная близость.

<http://klimaleksus.narod.ru/Files/T/asscmp0V1.htm>

Это работает!  
Для каждой точки ищу ближайшую точку на второй прямой, и запоминаю её номер.  
Если две точки на разных прямых считают друг друга ближайшими – то режу по ним.  
Проблем нет ни с поиском, ни с длинными невыгодными разрезами – потому что если ближайшая точка уже занята другим разрезом, то значит для неё текущая не ближайшая, и резать не надо.  
Как обобщение на случай нескольких прямых можно рассматривать попарную близость – пусть каждая точка запоминает ближайших на остальных прямых. И резать через всю группу, если они все считают друг друга ближайшими.

Осталась проблема таймлага. Он дискретный, а не плавный.  
То есть длительность и скорость всех диалогов одинакова. Но во время уходов на рекламу синхронизация теряется.  
Возможно, эти кусочки можно выявить автоматически, потому что разрыв отрезков очень большой (но подбирать надо как-то адаптивно). Потом порезать по рекламе, и устроить регрессию.

Либо проще – взять некий порог (возможно адаптивно), меньше минимальной длительности этих самых пауз от вырезанной рекламы. Потом пройти по всем отрезкам, и если паузы больше, чем порок – сделать её размером ровно с порог, чтобы начала очередных отрезков совпали.

Надо бы вывести все длины промежутков между всеми отрезками и построить таблицу или график…

Ого, даже порогом ограничить вот так просто не получается. Если в одном варианте субтитров, скажем, заставочная песня сопровождена текстом, а в другой – нет, то пустота вместо неё сворачивается в порог, и всё дальнейшее соответствие неверно.

Как-то параллельно надо что ли длинные промежутки пауз искать…

Да наконец!  
<http://klimaleksus.narod.ru/Files/T/asscmp0V2.htm>  
(оказывается, отображается нормально только в Firefox)

Смог выровнять по паузам. Алгоритм такой:

Выбираем некоторый порог, скажем, три секунды. Далее фиксируем первую фразу на одной и другой прямой.  
Ищем на каждой прямой вперёд первую ближайшую паузу между отрезками, превосходящую порог.  
Если не найдено ни на одной, либо какая-то исчерпана (если мы начали искать от её конца – когда зафиксированное начало уже ушло, окончание алгоритма) – выходить из выравнивания и перейти к основному алгоритму разбиения.

Теперь, у нас есть две дырки (если одна, то втору считаем максимально удалённой). Берём ту из них, конец которой ближе по времени.

Теперь на соседней прямой ищем ближайшую точку начала отрезка, которая соответствует началу следующего отрезка за нашей дыркой на нашей прямой.

Выравниваем! Двигаем все последующие точки на одной из прямых вперёд. На той, точка выравнивания которой ранее (мы же взяли одну точку, и искали соответствующую ближайшую, которая могла быть как до, так и после неё).

Переносим фиксирование на точки, следующие за теми, по которым мы выровняли, и повторяем алгоритм.

О, и я даже придумал, как автоматически выбирать порог!  
Пусть он сначала будет минимальным – полсекунды. Каждый раз, когда мы собираемся выровнять – проверяем, превосходит ли добавляемая величина этот порог.  
И если да, то отменяем все сделанные манипуляции, сбрасываем массив и увеличиваем порог. Скажем, ещё на полсекунды. И повторяем всё заново до тех пор, пока выравнивание ни разу не перестанет превышать его.  
Ага, тут можно даже бинарный поиск применять, но это уж чересчур. Добавление полсекунды и полный пересчёт вполне работают, тем более что чем меньше порог – тем быстрее произойдёт сброс.  

А ещё я думал устроить регрессию на участках, которые получаются выравниванием, но вроде и без этого всё отлично вышло.

Белые горизонтальные линии на страничке – разрезы выравнивания. Рядом есть вертикальная чёрточка – на столько были сдвинуты вперёд реплики на соответствующей прямой.

Всё, осталось лишь обобщить на три и более прямых…

Фу-у, я с многомерным массивом запарился…

Не могу сообразить, как попарную взаимность получить. Вот у меня короче что есть:  
– N прямых.  
– На каждой из них P(n) точек.  
– Каждая из них считает «ближайшей» Bn(i,m) одну из точек на каждой из оставшихся прямых (n≠m)

Я, например, храню это вот в таком массиве: M[n][i][m]=j, где  
n – исходная прямая (0..N-1)  
i – номер точки на ней (0..P(n)-1)  
m – целевая прямая (0..N-1)  
j – номер точки на целевой (0..P(m)-1)

Изначально я хотел пройти по нему, и делать  
t=M[n][i][m]; if (M[m][t][n]==i) {/\* у точек взаимная близость \*/}

, но оказалось что точки других прямых, которые текущая точка на текущей прямой считает ближайшими к себе, даже если они в свою очередь для этой прямой считают данную точку ближайшей и к себе – они не обязаны быть ближайшими между собой!

Для двух прямых это неверно. Для трёх – определяется очень просто (достаточно проверить взаимную близость двух концов ближайших точек от текущей) , но для >=4 – вообще неочевидно, как проверять.

Я думал над чем-то вроде  
for(i=1;i<n;i++) { for(j=0;j<i;j++) { /\* как-то проверять близость для прямых i и j \*/ }}  
, или например собирать в один массив все найденные близости, а если там уже есть – то проверять, что все имеющиеся тоже взаимно близки с добавляемым.

Но в обоих случаях надо как-то удобно представить данные, и как-то хорошо идти по ним циклами.  
Если что, массивы у меня безразмерные и ассоциативные, можно обращаться к неинициализированным элементам и реагировать на это; любой уровень вложенности.

Мне уже несколько раз казалось, что я придумал правильный метод хранения и обработки, но как только я начинаю программировать – понимаю, что всё совершенно не стыкуется…

Ещё у меня сверху нужно отодвигать часть файла, если одна из дорожек внезапно закончилась, чтобы другие не пытались безуспешно взаимно бизиться с ней. Но это вроде я смогу закодить.

Ну и сам финал – импорт .ass, экспорт .csv  
И интерактивное сравнение-голосование ^^

Мне нужно как-то высчитать «группы взаимности», в которых все точки между собой попарно ближайшие…

Более того, как обходить прямые?  
Если только одну – то она может оказаться короче других, и некоторые точки прочих не будут даже рассмотрены (а там есть условие, что они могут быть взаимно близки между собой, отбросив эту короткую).  
А если все – так дубли же!

Если мы сравниваем eng+a2a+tdt, то из того, что в последнем одна фраза, а в первых двух – две, то это значит, что меж ними нет никакой ещё одной группы. И лишние линии надо выкинуть.

Но я сделаю так: когда обнаруживается «большая» дырка на одно прямой – её концы отмечаются, чтобы во-первых, выровнять всё что дальше; а во-вторых – чтобы на этом промежутке её влияние на взаимность других прямых нивелировалось.  
Тогда, если останется лишь одна прямая – например, наша заставочная песня – каждая фраза ляжет в отдельную ячейку, как взаимная сама с собой.

Но если на нормальном промежутке хоть у кого-то нет взаимности – отбрасывать! На этом строилась первоначальная версия алгоритма для двух прямых, и она работала идеально!  
Вернее, проблема была только в одном месте, когда точки продолжительно идут в шахматном порядке. Но там даже не понятно, что делать (особенно потому что я самих фраз-то не вижу…), может будет понятно, когда таблицу с текстом получу…

У меня есть n линий, на которых стоят точки (одномерные).  
Везде далее индекс «c» можно не учитывать.  
В массиве f[h][i][c] – координаты i-той точки на h-той линии. На одной линии f[h].length точек.

Сначала я хочу найти для каждой точки на каждой из линий ближайшую точку.  
Завожу особый массив m[h][i][H][c]=j – это j-координата точки на H-той линии, и эта точка – ближайшая к точке i на h-той линии.

m=[];  
for(h=0;h<n;h++){ // линии  
m[h]=[];  
for(i=0;i<f[h].length;i++){ // их точки  
m[h][i]=[];  
for(H=0;H<n;H++)m[h][i][H]={b:-1,e:-1}; // условно m[h][i][H][c]=-1;  
}}

– изначально заполняю «-1», то если ближайшая точка ни для кого не известна. Теперь:

for(c in {b:'',e:''}){ // условно c=0  
for(h=0;h<n;h++){ // по всем линиям  
// для текущей линии:  
for(i=0;i<f[h].length;i++){ // по всем её точкам  
V=f[h][i][c]; // численное значение текущей точки  
m[h][i][h][c]=I; // сама для себя автоматически ближайшая  
for(H=0;H<n;H++){ // по всем другим линиям (и по своей тоже)  
d=-1;uu=-1; // счётчики расстояния обнуляем  
for(j=0;j<f[H].length;j++){ // по всем точкам «второй» линии  
v=V-f[H][j][c]; // расстояние от изначальной до текущей  
if(v<0)v=-v; // по модулю…  
if(d==-1||v<=d){ // если первая или ближе –  
d=v;uu=j; // запоминаем новое кратчайшее, и индекс  
}} // наконец,  
if(uu==-1)console.log(h,i,H,c); // (не выполнится, всё верно)  
m[h][i][H][c]=uu; // присваиваем в нужный массив  
}}  
// закончили  
}}

Проблемы возникают уже на следующем шаге:

for(c in {b:'',e:''})for(h=0;h<n;h++)for(i=0;i<f[h].length;i++)for(H=0;H<n;H++)if((v=m[h][i][H][c])>-1&&i!=m[H][v][h][c])m[h][i][H][c]=m[H][v][h][c]=-1;

Я пытаюсь проверить, считают ли какие-то точки друг друга ближайшими по взаимности, и если нет – отбрасываю их.  
Если v=m[h][i][H][c] – это для линии h и её точки i индекс ближайшей точки на линии H.  
Значит, если я возьму обратное, m[H][v][h][c] – то должен получить текущий же индекс, в том случае, если для линии H и этому индексу точки, ближайшей на текущей линии h будет иметь текущий индекс i.

Но в результате я получаю очевидные ложные срабатывания на точках, которые являются взаимно близкими. Всё, что у меня дальше в коде (а там я ищу группы попарной взаимной близости, когда все точки на разных прямый близки между собой) становится неверным.

И я не могу понять, в чём проблема. Входные данные вроде тоже проверял (точки отсортированы по возрастанию на своих линиях). Метод поиска ближайшей неоднократно менял – сейчас он, кстати, едва ли самый оптимальный на отсортированном-то массиве…

<http://klimaleksus.narod.ru/Files/T/asscmp0V3.htm>  
– розовых не должно быть…

Фуф, релиз. Хотя бы такой, без нормального интерфейса и без самой главной фишки, зачем это делалось.  
Но сам алгоритм – жжёт!  
<http://klimaleksus.narod.ru/Files/T/asscmp1V0.htm>

Инструкция:  
– поместить несколько разных .ass субтитров к одной серии пони в одну папку.  
– на страничке активировать элемент выбора файлов, и выделить их все (оптимально 2-3 файла)  
– нажать «открыть» в самом диалоге, и всё. Прокрутить до низу!  

Если нет субтитров под рукой, то вот:  
<http://klimaleksus.narod.ru/Files/T/subs.zip>

Он пытается определить, как файлы порезать на группы так, чтобы в них попали одинаковые по смыслу куски.

Умеет вырезать рекламу (с автоподбором порога), корректно обрабатывает интро, и небольшую линейную регрессию устраивает.

, правда я себе облегчил задачу в конце, когда понял, что не имеет смысла, скажем, сравнивать между собой лишь три из четырёх дорожек, когда одна уже кончилась или в ней дыра.  
Потому что в итоге это же для начисления балов, а так иначе что получается – что в одном столбце будет меньше ячеек, чем в других? И голоса за эти ущербные строчки потеряют смысл.  
То есть добавление пустого файла всё действительно ломает – его нельзя сравнить «построчно» с остальными, а значит и их разбиение на строчки должно пропасть.  
Зато, с другой стороны, добавление точной копии одного из файлов – вообще ничего не меняет, это да.

Готов, в той или иной степени, мой скрипт сравнения субтитров. Он выполняет две различные функции:  
1\) Позволяет получить численную субъективную оценку, сколько строчек лучше переведено у нас, чем у анонимов, и наоборот. Нужно просто кликнуть мышкой по лучшему из вариантов в таблице.  
2\) Позволяет по словам сравнить транскрипт анонимов с транскриптом от Хасбро.  
Вот: <http://klimaleksus.narod.ru/Files/4/asscmp1V1.htm>

И файлик с материалом и сохранёнными примерами:  
<http://klimaleksus.narod.ru/Files/4/asscmp_test.zip> , копия скрипта вложена; прочитайте встроенную справку.

Для пословного анализа, можно просто запустить анонимский английский и хасбро, в режиме Diff, без strict.  
Я сохранил его, можете просто открыть файл /diff через нижнюю форму загрузки файла.

А для быстрого сравнения нас с анонимами, открываете наш и их .ass в обычном режиме, этого уже достаточно.  
Но я добавил туда и английские варианты, чтобы во-первых, иметь ещё две категории оценок (итого пять: «не оценивается» / «мы выиграли» / «мы проиграли» / «боевая ничья» / «просрано всеми»), а во-вторых, чтобы по транскрипту тоже ориентироваться.

Метода объединения субъективных оценок разных людей я пока не придумал, но сами оценки уже вроде вполне можно получать ^^

А пока правила такие:  
– загрузить файл «cmp» через нижнюю форму на страничке.  
– щёлкать в таблице по лучшим фразам из средних двух столбцов (анонимы слева, мы справа)  
– если переводы одинаково хороши, то отметить крайний правый столбец (транскрипт Хасбро)  
– если переводы безнадёжно плохи – то самый левый (транскрипт анонимов).  
– не нужно отмечать каждую-каждую строку, надо следить за разбиением. Если разбиение неэквивалентно (всё из-за транскрипта Хасбро, он какой-то кривой местами) – то оставлять некоторые строчки жёлтыми, нетронутыми. Обычно, когда в одной клетке фраза целиком, а в следующую почему-то выпала её часть – то оценивать вторую не следует.  
– сохранить результат!

Моё субъективное сравнение:  
<http://klimaleksus.narod.ru/Files/D/s6e14.zip>  
– открыть страничку, загрузить в неё файл через нижнюю форму выбора.  
Результат: / 6 / 60 / 60 / 182 / – побед и поражений, к сожалению, поровну. И это без учёта аж шести полностью провальных реплик, когда наш вариант, как выяснилось, неправильно интерпретировал оригинальный текст.  
Однако, я не засчитывал отдельно «жёстко надрали», когда вражеский вариант ударил в молоко (хотя по идее, под это можно забрать самый правый столбец, тогда отмечая равенство просто отсутствием выбора).

А ещё, я старался считать объективно. Например, рассматривал каждую реплику в контексте своих соседних, то есть не пытался собрать из двух потоков один хороший, а просто оценивал, насколько хорошо данная фраза вписывается в своё окружение.  
Поэтому, например, одна удачная реплика не заставит несколько следующих перетянуть чашу весов, потому что да, продолжение подходит к ней замечательно, но ведь и не лучше же, чем в другом столбце, соответствующее продолжение подходило к уже шутке похуже.

Если реплики, в принципе, равнозначны, то я не старался во что бы то ни стало отделить лучшую. Также, если они доносят мысль абсолютно разными путями (что уже делает их несравнимыми), но при этом каждый из них выглядит вполне хорошим, то это ничья.  
Однако если один из конкурирующих вариантов содержит хотя бы малый оттенок (может даже частица «-то» и есть единственное их различие) того, что присутствовало в исходной фразе, а другой вариант – нет, то это победа.

Такие общие штуки, как «go-go-go» или тот Рарькин болт, я вообще прямо не оценивал – можно считать это просто разным стилем, как например перевод имён и названий. И следовательно, все зависимые фразы рассматривались в своём контексте. И когда выигрывает одна, то это не значит, что в другом переводе «лучше бы чтобы была она» – а скорее сама конструкция, доносящая мысль лучшим способом, но уже со своей точки зрения.

Во всех спорных случаях я откатывался к ничьей.

HTML результата:  
<http://klimaleksus.narod.ru/Files/D/s6e14.htm>

> <http://klimaleksus.narod.ru/Files/D/s6e15.zip>  
> / 0 / 36 / 44 / 198 /  
> ДАСТ ИС ПРОГРЕССО!

---

[Назад](./)
